<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>char_draw.canvas API documentation</title>
    <meta name="description" content="module that implements a graphics package using block graphics on curses window" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#char_draw.canvas.Canvas">Canvas</a></span>
        
          
  <ul>
    <li class="mono"><a href="#char_draw.canvas.Canvas.__init__">__init__</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.arc">arc</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.circle">circle</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.clip_polygon">clip_polygon</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.cross_product_length">cross_product_length</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.from_rowcol">from_rowcol</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.get_bounds">get_bounds</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.get_maxxy">get_maxxy</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.init_win">init_win</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.intersect">intersect</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.is_convex">is_convex</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.line">line</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.poly_fill">poly_fill</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.polygon">polygon</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.polyline">polyline</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.put_pixel">put_pixel</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.rasterize">rasterize</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.rect">rect</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.refresh">refresh</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.round_text_position">round_text_position</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.round_text_x_position">round_text_x_position</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.round_text_y_position">round_text_y_position</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.set_win">set_win</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.textat">textat</a></li>
    <li class="mono"><a href="#char_draw.canvas.Canvas.to_rowcol">to_rowcol</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">char_draw.canvas</span> module</h1>
  <p>module that implements a graphics package using block graphics on curses window</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas" class="source">
    <pre><code># Copyright 2017 James P Goodwin chardraw unicode curses based graphics package
""" module that implements a graphics package using block graphics on curses window """
import locale
locale.setlocale(locale.LC_ALL,"")
import curses
import curses.ascii
import sys
import os
import math

class Canvas:
    """ primitive drawing surface attached to a curses window """

    to_mask = { 0:1, 1:2, 2:4, 3:8 }
    mask_to_char = {
        0 :'\u2008',
        1 :'\u2598',
        2 :'\u259d',
        3 :'\u2580',
        4 :'\u2596',
        5 :'\u258c',
        6 :'\u259e',
        7 :'\u259b',
        8 :'\u2597',
        9 :'\u259a',
        10:'\u2590',
        11:'\u259c',
        12:'\u2584',
        13:'\u2599',
        14:'\u259f',
        15:'\u2588'
        }

    char_to_mask = {
        '\u2008':0 ,
        '\u2598':1 ,
        '\u259d':2 ,
        '\u2580':3 ,
        '\u2596':4 ,
        '\u258c':5 ,
        '\u259e':6 ,
        '\u259b':7 ,
        '\u2597':8 ,
        '\u259a':9 ,
        '\u2590':10,
        '\u259c':11,
        '\u2584':12,
        '\u2599':13,
        '\u259f':14,
        '\u2588':15
        }

    def __init__(self, win = None ):
        """ constructor, can be initialized with a window to draw on, otherwise window must be set later by set_window """
        self.set_win(win)

    def to_rowcol(self, x, y ):
        """ return character row col for input x,y coordinates """
        return (int(y/2),int(x/2))

    def from_rowcol(self, row, col ):
        """ return the pixel location of a character position, returns upper left pixel in matrix"""
        return (int(row)*2,int(col)*2)

    def round_text_position(self, x, y):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(x,y)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if y1 < y:
            y = y + h/2
        if x1 < x:
            x = x + w/2
        return x, y

    def round_text_x_position(self, x):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(x,0)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if x1 < x:
            x = x + w/2
        return x

    def round_text_y_position(self, y):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(0,y)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if y1 < y:
            y = y + h/2
        return y

    def set_win(self, win ):
        """ point this canvas at a window and initialize things, will blank out the window """
        self.win = win
        self.init_win()

    def init_win(self):
        """ initializes the window and sets up all of the defaults """
        curses.init_pair(5,curses.COLOR_BLACK,curses.COLOR_BLACK)
        curses.init_pair(1,curses.COLOR_GREEN,curses.COLOR_BLACK)
        curses.init_pair(2,curses.COLOR_RED,curses.COLOR_BLACK)
        curses.init_pair(3,curses.COLOR_CYAN,curses.COLOR_BLACK)
        curses.init_pair(4,curses.COLOR_WHITE,curses.COLOR_BLACK)

        self.green = curses.color_pair(1)
        self.red = curses.color_pair(2)
        self.cyan = curses.color_pair(3)
        self.white = curses.color_pair(4)
        self.black = curses.color_pair(5)

        if curses.can_change_color():
            self.color_min = 8
            self.color_max = 256

            red = 0
            green = 100
            blue = 20
            for c in range(self.color_min,self.color_max):
                curses.init_color(c,red,green,blue)
                red += 23
                green += 33
                blue += 53
                red = red % 1000
                green = green % 1000
                blue = blue % 1000

            for cidx in range(self.color_min,self.color_max):
                curses.init_pair(cidx,cidx,curses.COLOR_BLACK)
        else:
            self.color_min = 0
            self.color_max = 8

        if self.win:
            self.max_y,self.max_x = self.win.getmaxyx()
            self.char_map = [[None] * self.max_y for i in range(self.max_x)]
            self.max_y = self.max_y * 2
            self.max_x = self.max_x * 2
        else:
            self.max_y,self.max_x = (0,0)
            self.char_map = None

    def refresh( self ):
        """ refresh the display after drawing """
        self.win.refresh()

    def get_maxxy( self ):
        """ return the maximum number of x and y pixels that are available in this canvas """
        return (self.max_x,self.max_y)

    def put_pixel( self, x,y, color, set = True ):
        """ turn on a pixel with the color indicated """
        if x < 0 or x >= self.max_x or y < 0 or y >= self.max_y:
            return
        row,col = self.to_rowcol(x,y)
        mask = self.to_mask[(int(x)%2)+((int(y)%2)*2)]

        if not self.char_map[col][row]:
            current_mask = 0
        else:
            current_mask = self.char_to_mask[self.char_map[col][row]]

        if set:
            self.char_map[col][row] = self.mask_to_char[ mask | current_mask ]
        else:
            self.char_map[col][row] = self.mask_to_char[ mask ^ current_mask ]
        try:
            self.win.addstr(row,col,self.char_map[col][row].encode('utf_8'),color)
        except:
            pass

    def line(self, x0, y0, x1, y1, color, put_pixel=None ):
        """ draw a line between x0,y0 and x1,y1 in color """
        x0 = int(x0)
        x1 = int(x1)
        y0 = int(y0)
        y1 = int(y1)

        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        sx = -1 if x0 > x1 else 1
        sy = -1 if y0 > y1 else 1
        if dx > dy:
            err = dx / 2.0
            while x != x1:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x, y, color)
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x, y, color)
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy
        if put_pixel:
            put_pixel(x, y, color)
        else:
            self.put_pixel(x,y,color)

    def intersect( self, seg1, seg2, clip_to_seg = False ):
        """ find the intersection of two segments as tuples (x0,y0,x1,y1) returns tuple (x,y) if no intersection returns None """
        def lineform( seg ):
            """ return A, B, C for the standard line formula Ax + By = C """
            A = float(seg[1]-seg[3])
            B = float(seg[2]-seg[0])
            C = A*seg[0]+B*seg[1]
            return (A,B,C)

        l1 = lineform(seg1)
        l2 = lineform(seg2)

        det = l1[0]*l2[1] - l2[0]*l1[1]
        if det != 0:
            x = (l2[1]*l1[2] - l1[1]*l2[2])/det
            y = (l1[0]*l2[2] - l2[0]*l1[2])/det

            if clip_to_seg:
                if x >= min(seg1[0],seg1[2]) and x <= max(seg1[0],seg1[2]) and y >= min(seg1[1],seg1[3]) and y <= max(seg1[1],seg1[3]):
                    return (int(x),int(y))
            else:
                return (int(x),int(y))
        return None

    def cross_product_length( self, pA,pB,pC ):
        """ compute the cross product of AB x BC """
        BAx = float(pA[0] - pB[0])
        BAy = float(pA[1] - pB[1])
        BCx = float(pC[0] - pB[0])
        BCy = float(pC[1] - pB[1])

        return (BAx * BCy - BAy * BCx)

    def is_convex( self, points ):
        """ take a list of (x,y) tuples representing the vertecies of a polygon in order and return True if it represents a convex polygon, False otherwise """
        got_negative = False
        got_positive = False
        num_points = len(points)
        if num_points <= 3:
            return True


        min_x,min_y,max_x,max_y = self.get_bounds(points)
        if max_x-min_x <= 1.0 or max_y-min_y <= 1.0:
            return True

        for A in range(num_points):
            B = (A+1)%num_points
            C = (B+1)%num_points
            cross_product = self.cross_product_length(points[A],points[B],points[C])
            if cross_product < 0:
                got_negative = True
            elif cross_product > 0:
                got_positive = True

        return not (got_negative and got_positive)

    def get_bounds(self,points):
        """ return tuple (min_x,min_y,max_x,max_y) for list of points """
        min_x = -1
        min_y = -1
        max_x = -1
        max_y = -1
        for x,y in points:
            if min_x < 0 or x < min_x:
                min_x = x
            if min_y < 0 or y < min_y:
                min_y = y
            if max_x < 0 or x > max_x:
                max_x = x
            if max_y < 0 or y > max_y:
                max_y = y
        return (min_x,min_y,max_x,max_y)

    def clip_polygon(self, points, minX, minY, maxX, maxY, dir=-1 ):
        """ clip a polygon against the bounds exressed by minX,minY to maxX,maxY and return either None for nothing inside or the points for the polygon dir is -1 all,0=top,1=right,2=bottom,3=left """
        def inside( p, minX, minY, maxX, maxY, dir ):
            x,y = p
            if dir == 0:
                return(y >= minY)
            elif dir == 1:
                return(x < maxX)
            elif dir == 2:
                return(y < maxY)
            elif dir == 3:
                return(x >= minX)

        def intersect(sp, ep, minX, minY, maxX, maxY, dir ):
            x0,y0 = sp
            x1,y1 = ep
            s1 = (x0,y0,x1,y1)
            if dir == 0:
                s2 = (minX,minY,maxX,minY)
            elif dir == 1:
                s2 = (maxX,minY,maxX,maxY)
            elif dir == 2:
                s2 = (minX,maxY,maxX,maxY)
            elif dir == 3:
                s2 = (minX,minY,minX,maxY)
            return self.intersect(s1,s2,False)

        if dir == -1:
            for d in [0,1,2,3]:
                points = self.clip_polygon(points,minX,minY,maxX,maxY,d)
                if not points:
                    return None
            return points
        else:
            sp = points[-1]
            out_points = []
            for ep in points:
                if inside(ep,minX,minY,maxX,maxY,dir):
                    if inside(sp,minX,minY,maxX,maxY,dir):
                        out_points.append(ep)
                    else:
                        ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                        out_points.append(ip)
                        out_points.append(ep)
                else:
                    if inside(sp,minX,minY,maxX,maxY,dir):
                        ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                        out_points.append(ip)
                sp = ep
            return out_points if out_points else None


    def rasterize( self, points, color, put_pixel=None):
        """ sort points representing the boundary of a filled shape and rasterize by filling lines with color """
        ps = sorted(points,key=lambda x: (x[1],x[0]))
        sp = iter(ps)
        p2 = p1 = next(sp,None)
        si = 0
        last = None
        while p2:
            last = p2
            p2 = next(sp,None)
            if not p2:
                if put_pixel:
                    put_pixel(p1[0],p1[1],color)
                else:
                    self.put_pixel(p1[0],p1[1],color)
            else:
                if p2[1] == p1[1]:
                    continue
                else:
                    self.line(p1[0],p1[1],last[0],last[1],color,put_pixel)
                    p1 = p2



    def circle(self, x0, y0, radius, color, fill = False, put_pixel=None ):
        """ draw a circle centered at x0,y0 of radius radius in color """
        self.arc(x0,y0,radius,0,360,color,fill,put_pixel)

    def arc(self,x0,y0,radius,a0,a1,color,fill=False,put_pixel=None,just_points=False):
        """ draw an arc between a0 degrees to a1 degrees centered at x0,y0 with radius and color """
        def circle_point(x0,y0,a,radius):
            return (x0+(1.5*math.cos(math.radians(a))*radius), y0+math.sin(math.radians(a))*radius)

        points = []
        points.append((x0,y0))
        a = a0
        while a <= a1:
            xp,yp = circle_point(x0,y0,a,radius)
            a = a + 1.0
            points.append((xp,yp))
                                

        if just_points:
            for x,y in points:
                put_pixel(x,y,color)
        else:
            self.polygon(points,color,fill,put_pixel)

    def rect(self,x0,y0,x1,y1,color,fill=False,put_pixel=None):
        """ draw a rectangle bounding x0,y0, x1,y1, in color == color optionally filling """
        x0 = int(x0)
        x1 = int(x1)
        y0 = int(y0)
        y1 = int(y1)

        if not fill:
            self.line(x0,y0,x0,y1,color)
            self.line(x0,y1,x1,y1,color)
            self.line(x1,y1,x1,y0,color)
            self.line(x1,y0,x0,y0,color)
        else:
            if y1 < y0:
                y=y0
                y0=y1
                y1 = y
            for y in range(y0,y1):
                self.line(x0,y,x1,y,color,put_pixel)

    def textat(self,x,y,color,message):
        """ draw a text message at a coordinate in the color specified """
        x,y = self.round_text_position(x,y)

        height, width = self.from_rowcol(1,len(message))

        if x < 0 or x >self.max_x or y < 0 or y >self.max_y:
            return

        if y + height > self.max_y:
            return

        if x + height > self.max_x:
            clip_height,clip_width = self.to_rowcol(1,(self.max_x-x))
            if clip_width > 0:
                message = message[:clip_width]
            else:
                return

        row,col = self.to_rowcol(x,y)
        self.win.addstr(row,col,message.encode('utf_8'),color)

    def polyline(self,points,color,put_pixel=None):
        """ draw a polyline defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color """
        i = iter(points)
        p1 = next(i,None)
        while p1:
            p2 = next(i,None)
            if p2:
                self.line(p1[0],p1[1],p2[0],p2[1],color,put_pixel)
            else:
                if put_pixel:
                    put_pixel(p1[0],p1[1],color)
                else:
                    self.put_pixel(p1[0],p1[1],color)
            p1 = p2

    def poly_fill(self,points,color,put_pixel = None):
        """ fill a concave polygon by recursively subdividing until we get a convex polygon """
        clips = []

        minX,minY,maxX,maxY = self.get_bounds(points)

        minX = float(minX)
        minY = float(minY)
        maxX = float(maxX)
        maxY = float(maxY)

        midX = (minX+maxX)/2.0
        midY = (minY+maxY)/2.0

        clips.append((minX,minY,midX,midY))
        clips.append((midX,minY,maxX,midY))
        clips.append((midX,midY,maxX,maxY))
        clips.append((minX,midY,midX,maxY))

        while clips:
            minX,minY,maxX,maxY = clips.pop(0)
            if int(minX)==int(maxX) or int(minY)==int(maxY):
                continue

            p = self.clip_polygon(points,minX,minY,maxX,maxY)
            if p:
                if self.is_convex(p):
                    self.polygon(p,color,True,put_pixel)
                else:
                    midX = (minX+maxX)/2.0
                    midY = (minY+maxY)/2.0
                    if midX - minX < 1.0 or midY - minY < 1.0 or maxX - midX < 1.0 or maxY - midY < 1.0:
                        continue
                    clips.append((minX,minY,midX,midY))
                    clips.append((midX,minY,maxX,midY))
                    clips.append((midX,midY,maxX,maxY))
                    clips.append((minX,midY,midX,maxY))

    def polygon(self,points,color,fill=False,put_pixel=None):
        """ draw a polygon defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color
        the last point will be connected to the first point. polygons can be filled. """

        if not points:
            return

        convex = True
        if fill:
            convex = self.is_convex(points)

        poly_pixels = []
        def put_poly_pixel(x,y,color):
            poly_pixels.append((x,y))

        i = iter(points)
        first = p1 = next(i,None)
        while p1:
            p2 = next(i,None)
            if p2:
                last = p2
                self.line(p1[0],p1[1],p2[0],p2[1],color,put_poly_pixel)
            else:
                last = p1
                put_poly_pixel(p1[0],p1[1],color)
            p1 = p2
        self.line(first[0],first[1],last[0],last[1],color,put_poly_pixel)

        if not fill:
            for x,y in poly_pixels:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x,y,color)
        else:
            if convex:
                self.rasterize( poly_pixels, color, put_pixel)
            else:
                for x,y in poly_pixels:
                    if put_pixel:
                        put_pixel(x,y,color)
                    else:
                        self.put_pixel(x,y,color)
                self.poly_fill(points,color,put_pixel)
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="char_draw.canvas.Canvas" class="name">class <span class="ident">Canvas</span></p>
      
  
    <div class="desc"><p>primitive drawing surface attached to a curses window</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas" class="source">
    <pre><code>class Canvas:
    """ primitive drawing surface attached to a curses window """

    to_mask = { 0:1, 1:2, 2:4, 3:8 }
    mask_to_char = {
        0 :'\u2008',
        1 :'\u2598',
        2 :'\u259d',
        3 :'\u2580',
        4 :'\u2596',
        5 :'\u258c',
        6 :'\u259e',
        7 :'\u259b',
        8 :'\u2597',
        9 :'\u259a',
        10:'\u2590',
        11:'\u259c',
        12:'\u2584',
        13:'\u2599',
        14:'\u259f',
        15:'\u2588'
        }

    char_to_mask = {
        '\u2008':0 ,
        '\u2598':1 ,
        '\u259d':2 ,
        '\u2580':3 ,
        '\u2596':4 ,
        '\u258c':5 ,
        '\u259e':6 ,
        '\u259b':7 ,
        '\u2597':8 ,
        '\u259a':9 ,
        '\u2590':10,
        '\u259c':11,
        '\u2584':12,
        '\u2599':13,
        '\u259f':14,
        '\u2588':15
        }

    def __init__(self, win = None ):
        """ constructor, can be initialized with a window to draw on, otherwise window must be set later by set_window """
        self.set_win(win)

    def to_rowcol(self, x, y ):
        """ return character row col for input x,y coordinates """
        return (int(y/2),int(x/2))

    def from_rowcol(self, row, col ):
        """ return the pixel location of a character position, returns upper left pixel in matrix"""
        return (int(row)*2,int(col)*2)

    def round_text_position(self, x, y):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(x,y)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if y1 < y:
            y = y + h/2
        if x1 < x:
            x = x + w/2
        return x, y

    def round_text_x_position(self, x):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(x,0)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if x1 < x:
            x = x + w/2
        return x

    def round_text_y_position(self, y):
        """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
        r,c = self.to_rowcol(0,y)
        y1,x1 = self.from_rowcol(r,c)
        h,w = self.from_rowcol(1,1)
        if y1 < y:
            y = y + h/2
        return y

    def set_win(self, win ):
        """ point this canvas at a window and initialize things, will blank out the window """
        self.win = win
        self.init_win()

    def init_win(self):
        """ initializes the window and sets up all of the defaults """
        curses.init_pair(5,curses.COLOR_BLACK,curses.COLOR_BLACK)
        curses.init_pair(1,curses.COLOR_GREEN,curses.COLOR_BLACK)
        curses.init_pair(2,curses.COLOR_RED,curses.COLOR_BLACK)
        curses.init_pair(3,curses.COLOR_CYAN,curses.COLOR_BLACK)
        curses.init_pair(4,curses.COLOR_WHITE,curses.COLOR_BLACK)

        self.green = curses.color_pair(1)
        self.red = curses.color_pair(2)
        self.cyan = curses.color_pair(3)
        self.white = curses.color_pair(4)
        self.black = curses.color_pair(5)

        if curses.can_change_color():
            self.color_min = 8
            self.color_max = 256

            red = 0
            green = 100
            blue = 20
            for c in range(self.color_min,self.color_max):
                curses.init_color(c,red,green,blue)
                red += 23
                green += 33
                blue += 53
                red = red % 1000
                green = green % 1000
                blue = blue % 1000

            for cidx in range(self.color_min,self.color_max):
                curses.init_pair(cidx,cidx,curses.COLOR_BLACK)
        else:
            self.color_min = 0
            self.color_max = 8

        if self.win:
            self.max_y,self.max_x = self.win.getmaxyx()
            self.char_map = [[None] * self.max_y for i in range(self.max_x)]
            self.max_y = self.max_y * 2
            self.max_x = self.max_x * 2
        else:
            self.max_y,self.max_x = (0,0)
            self.char_map = None

    def refresh( self ):
        """ refresh the display after drawing """
        self.win.refresh()

    def get_maxxy( self ):
        """ return the maximum number of x and y pixels that are available in this canvas """
        return (self.max_x,self.max_y)

    def put_pixel( self, x,y, color, set = True ):
        """ turn on a pixel with the color indicated """
        if x < 0 or x >= self.max_x or y < 0 or y >= self.max_y:
            return
        row,col = self.to_rowcol(x,y)
        mask = self.to_mask[(int(x)%2)+((int(y)%2)*2)]

        if not self.char_map[col][row]:
            current_mask = 0
        else:
            current_mask = self.char_to_mask[self.char_map[col][row]]

        if set:
            self.char_map[col][row] = self.mask_to_char[ mask | current_mask ]
        else:
            self.char_map[col][row] = self.mask_to_char[ mask ^ current_mask ]
        try:
            self.win.addstr(row,col,self.char_map[col][row].encode('utf_8'),color)
        except:
            pass

    def line(self, x0, y0, x1, y1, color, put_pixel=None ):
        """ draw a line between x0,y0 and x1,y1 in color """
        x0 = int(x0)
        x1 = int(x1)
        y0 = int(y0)
        y1 = int(y1)

        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        sx = -1 if x0 > x1 else 1
        sy = -1 if y0 > y1 else 1
        if dx > dy:
            err = dx / 2.0
            while x != x1:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x, y, color)
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x, y, color)
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy
        if put_pixel:
            put_pixel(x, y, color)
        else:
            self.put_pixel(x,y,color)

    def intersect( self, seg1, seg2, clip_to_seg = False ):
        """ find the intersection of two segments as tuples (x0,y0,x1,y1) returns tuple (x,y) if no intersection returns None """
        def lineform( seg ):
            """ return A, B, C for the standard line formula Ax + By = C """
            A = float(seg[1]-seg[3])
            B = float(seg[2]-seg[0])
            C = A*seg[0]+B*seg[1]
            return (A,B,C)

        l1 = lineform(seg1)
        l2 = lineform(seg2)

        det = l1[0]*l2[1] - l2[0]*l1[1]
        if det != 0:
            x = (l2[1]*l1[2] - l1[1]*l2[2])/det
            y = (l1[0]*l2[2] - l2[0]*l1[2])/det

            if clip_to_seg:
                if x >= min(seg1[0],seg1[2]) and x <= max(seg1[0],seg1[2]) and y >= min(seg1[1],seg1[3]) and y <= max(seg1[1],seg1[3]):
                    return (int(x),int(y))
            else:
                return (int(x),int(y))
        return None

    def cross_product_length( self, pA,pB,pC ):
        """ compute the cross product of AB x BC """
        BAx = float(pA[0] - pB[0])
        BAy = float(pA[1] - pB[1])
        BCx = float(pC[0] - pB[0])
        BCy = float(pC[1] - pB[1])

        return (BAx * BCy - BAy * BCx)

    def is_convex( self, points ):
        """ take a list of (x,y) tuples representing the vertecies of a polygon in order and return True if it represents a convex polygon, False otherwise """
        got_negative = False
        got_positive = False
        num_points = len(points)
        if num_points <= 3:
            return True


        min_x,min_y,max_x,max_y = self.get_bounds(points)
        if max_x-min_x <= 1.0 or max_y-min_y <= 1.0:
            return True

        for A in range(num_points):
            B = (A+1)%num_points
            C = (B+1)%num_points
            cross_product = self.cross_product_length(points[A],points[B],points[C])
            if cross_product < 0:
                got_negative = True
            elif cross_product > 0:
                got_positive = True

        return not (got_negative and got_positive)

    def get_bounds(self,points):
        """ return tuple (min_x,min_y,max_x,max_y) for list of points """
        min_x = -1
        min_y = -1
        max_x = -1
        max_y = -1
        for x,y in points:
            if min_x < 0 or x < min_x:
                min_x = x
            if min_y < 0 or y < min_y:
                min_y = y
            if max_x < 0 or x > max_x:
                max_x = x
            if max_y < 0 or y > max_y:
                max_y = y
        return (min_x,min_y,max_x,max_y)

    def clip_polygon(self, points, minX, minY, maxX, maxY, dir=-1 ):
        """ clip a polygon against the bounds exressed by minX,minY to maxX,maxY and return either None for nothing inside or the points for the polygon dir is -1 all,0=top,1=right,2=bottom,3=left """
        def inside( p, minX, minY, maxX, maxY, dir ):
            x,y = p
            if dir == 0:
                return(y >= minY)
            elif dir == 1:
                return(x < maxX)
            elif dir == 2:
                return(y < maxY)
            elif dir == 3:
                return(x >= minX)

        def intersect(sp, ep, minX, minY, maxX, maxY, dir ):
            x0,y0 = sp
            x1,y1 = ep
            s1 = (x0,y0,x1,y1)
            if dir == 0:
                s2 = (minX,minY,maxX,minY)
            elif dir == 1:
                s2 = (maxX,minY,maxX,maxY)
            elif dir == 2:
                s2 = (minX,maxY,maxX,maxY)
            elif dir == 3:
                s2 = (minX,minY,minX,maxY)
            return self.intersect(s1,s2,False)

        if dir == -1:
            for d in [0,1,2,3]:
                points = self.clip_polygon(points,minX,minY,maxX,maxY,d)
                if not points:
                    return None
            return points
        else:
            sp = points[-1]
            out_points = []
            for ep in points:
                if inside(ep,minX,minY,maxX,maxY,dir):
                    if inside(sp,minX,minY,maxX,maxY,dir):
                        out_points.append(ep)
                    else:
                        ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                        out_points.append(ip)
                        out_points.append(ep)
                else:
                    if inside(sp,minX,minY,maxX,maxY,dir):
                        ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                        out_points.append(ip)
                sp = ep
            return out_points if out_points else None


    def rasterize( self, points, color, put_pixel=None):
        """ sort points representing the boundary of a filled shape and rasterize by filling lines with color """
        ps = sorted(points,key=lambda x: (x[1],x[0]))
        sp = iter(ps)
        p2 = p1 = next(sp,None)
        si = 0
        last = None
        while p2:
            last = p2
            p2 = next(sp,None)
            if not p2:
                if put_pixel:
                    put_pixel(p1[0],p1[1],color)
                else:
                    self.put_pixel(p1[0],p1[1],color)
            else:
                if p2[1] == p1[1]:
                    continue
                else:
                    self.line(p1[0],p1[1],last[0],last[1],color,put_pixel)
                    p1 = p2



    def circle(self, x0, y0, radius, color, fill = False, put_pixel=None ):
        """ draw a circle centered at x0,y0 of radius radius in color """
        self.arc(x0,y0,radius,0,360,color,fill,put_pixel)

    def arc(self,x0,y0,radius,a0,a1,color,fill=False,put_pixel=None,just_points=False):
        """ draw an arc between a0 degrees to a1 degrees centered at x0,y0 with radius and color """
        def circle_point(x0,y0,a,radius):
            return (x0+(1.5*math.cos(math.radians(a))*radius), y0+math.sin(math.radians(a))*radius)

        points = []
        points.append((x0,y0))
        a = a0
        while a <= a1:
            xp,yp = circle_point(x0,y0,a,radius)
            a = a + 1.0
            points.append((xp,yp))
                                

        if just_points:
            for x,y in points:
                put_pixel(x,y,color)
        else:
            self.polygon(points,color,fill,put_pixel)

    def rect(self,x0,y0,x1,y1,color,fill=False,put_pixel=None):
        """ draw a rectangle bounding x0,y0, x1,y1, in color == color optionally filling """
        x0 = int(x0)
        x1 = int(x1)
        y0 = int(y0)
        y1 = int(y1)

        if not fill:
            self.line(x0,y0,x0,y1,color)
            self.line(x0,y1,x1,y1,color)
            self.line(x1,y1,x1,y0,color)
            self.line(x1,y0,x0,y0,color)
        else:
            if y1 < y0:
                y=y0
                y0=y1
                y1 = y
            for y in range(y0,y1):
                self.line(x0,y,x1,y,color,put_pixel)

    def textat(self,x,y,color,message):
        """ draw a text message at a coordinate in the color specified """
        x,y = self.round_text_position(x,y)

        height, width = self.from_rowcol(1,len(message))

        if x < 0 or x >self.max_x or y < 0 or y >self.max_y:
            return

        if y + height > self.max_y:
            return

        if x + height > self.max_x:
            clip_height,clip_width = self.to_rowcol(1,(self.max_x-x))
            if clip_width > 0:
                message = message[:clip_width]
            else:
                return

        row,col = self.to_rowcol(x,y)
        self.win.addstr(row,col,message.encode('utf_8'),color)

    def polyline(self,points,color,put_pixel=None):
        """ draw a polyline defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color """
        i = iter(points)
        p1 = next(i,None)
        while p1:
            p2 = next(i,None)
            if p2:
                self.line(p1[0],p1[1],p2[0],p2[1],color,put_pixel)
            else:
                if put_pixel:
                    put_pixel(p1[0],p1[1],color)
                else:
                    self.put_pixel(p1[0],p1[1],color)
            p1 = p2

    def poly_fill(self,points,color,put_pixel = None):
        """ fill a concave polygon by recursively subdividing until we get a convex polygon """
        clips = []

        minX,minY,maxX,maxY = self.get_bounds(points)

        minX = float(minX)
        minY = float(minY)
        maxX = float(maxX)
        maxY = float(maxY)

        midX = (minX+maxX)/2.0
        midY = (minY+maxY)/2.0

        clips.append((minX,minY,midX,midY))
        clips.append((midX,minY,maxX,midY))
        clips.append((midX,midY,maxX,maxY))
        clips.append((minX,midY,midX,maxY))

        while clips:
            minX,minY,maxX,maxY = clips.pop(0)
            if int(minX)==int(maxX) or int(minY)==int(maxY):
                continue

            p = self.clip_polygon(points,minX,minY,maxX,maxY)
            if p:
                if self.is_convex(p):
                    self.polygon(p,color,True,put_pixel)
                else:
                    midX = (minX+maxX)/2.0
                    midY = (minY+maxY)/2.0
                    if midX - minX < 1.0 or midY - minY < 1.0 or maxX - midX < 1.0 or maxY - midY < 1.0:
                        continue
                    clips.append((minX,minY,midX,midY))
                    clips.append((midX,minY,maxX,midY))
                    clips.append((midX,midY,maxX,maxY))
                    clips.append((minX,midY,midX,maxY))

    def polygon(self,points,color,fill=False,put_pixel=None):
        """ draw a polygon defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color
        the last point will be connected to the first point. polygons can be filled. """

        if not points:
            return

        convex = True
        if fill:
            convex = self.is_convex(points)

        poly_pixels = []
        def put_poly_pixel(x,y,color):
            poly_pixels.append((x,y))

        i = iter(points)
        first = p1 = next(i,None)
        while p1:
            p2 = next(i,None)
            if p2:
                last = p2
                self.line(p1[0],p1[1],p2[0],p2[1],color,put_poly_pixel)
            else:
                last = p1
                put_poly_pixel(p1[0],p1[1],color)
            p1 = p2
        self.line(first[0],first[1],last[0],last[1],color,put_poly_pixel)

        if not fill:
            for x,y in poly_pixels:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x,y,color)
        else:
            if convex:
                self.rasterize( poly_pixels, color, put_pixel)
            else:
                for x,y in poly_pixels:
                    if put_pixel:
                        put_pixel(x,y,color)
                    else:
                        self.put_pixel(x,y,color)
                self.poly_fill(points,color,put_pixel)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#char_draw.canvas.Canvas">Canvas</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="char_draw.canvas.Canvas.char_to_mask" class="name">var <span class="ident">char_to_mask</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="char_draw.canvas.Canvas.mask_to_char" class="name">var <span class="ident">mask_to_char</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="char_draw.canvas.Canvas.to_mask" class="name">var <span class="ident">to_mask</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, win=None)</p>
    </div>
    

    
  
    <div class="desc"><p>constructor, can be initialized with a window to draw on, otherwise window must be set later by set_window</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.__init__', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.__init__" class="source">
    <pre><code>def __init__(self, win = None ):
    """ constructor, can be initialized with a window to draw on, otherwise window must be set later by set_window """
    self.set_win(win)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.arc">
    <p>def <span class="ident">arc</span>(</p><p>self, x0, y0, radius, a0, a1, color, fill=False, put_pixel=None, just_points=False)</p>
    </div>
    

    
  
    <div class="desc"><p>draw an arc between a0 degrees to a1 degrees centered at x0,y0 with radius and color</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.arc', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.arc" class="source">
    <pre><code>def arc(self,x0,y0,radius,a0,a1,color,fill=False,put_pixel=None,just_points=False):
    """ draw an arc between a0 degrees to a1 degrees centered at x0,y0 with radius and color """
    def circle_point(x0,y0,a,radius):
        return (x0+(1.5*math.cos(math.radians(a))*radius), y0+math.sin(math.radians(a))*radius)
    points = []
    points.append((x0,y0))
    a = a0
    while a <= a1:
        xp,yp = circle_point(x0,y0,a,radius)
        a = a + 1.0
        points.append((xp,yp))
                            
    if just_points:
        for x,y in points:
            put_pixel(x,y,color)
    else:
        self.polygon(points,color,fill,put_pixel)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.circle">
    <p>def <span class="ident">circle</span>(</p><p>self, x0, y0, radius, color, fill=False, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a circle centered at x0,y0 of radius radius in color</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.circle', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.circle" class="source">
    <pre><code>def circle(self, x0, y0, radius, color, fill = False, put_pixel=None ):
    """ draw a circle centered at x0,y0 of radius radius in color """
    self.arc(x0,y0,radius,0,360,color,fill,put_pixel)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.clip_polygon">
    <p>def <span class="ident">clip_polygon</span>(</p><p>self, points, minX, minY, maxX, maxY, dir=-1)</p>
    </div>
    

    
  
    <div class="desc"><p>clip a polygon against the bounds exressed by minX,minY to maxX,maxY and return either None for nothing inside or the points for the polygon dir is -1 all,0=top,1=right,2=bottom,3=left</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.clip_polygon', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.clip_polygon" class="source">
    <pre><code>def clip_polygon(self, points, minX, minY, maxX, maxY, dir=-1 ):
    """ clip a polygon against the bounds exressed by minX,minY to maxX,maxY and return either None for nothing inside or the points for the polygon dir is -1 all,0=top,1=right,2=bottom,3=left """
    def inside( p, minX, minY, maxX, maxY, dir ):
        x,y = p
        if dir == 0:
            return(y >= minY)
        elif dir == 1:
            return(x < maxX)
        elif dir == 2:
            return(y < maxY)
        elif dir == 3:
            return(x >= minX)
    def intersect(sp, ep, minX, minY, maxX, maxY, dir ):
        x0,y0 = sp
        x1,y1 = ep
        s1 = (x0,y0,x1,y1)
        if dir == 0:
            s2 = (minX,minY,maxX,minY)
        elif dir == 1:
            s2 = (maxX,minY,maxX,maxY)
        elif dir == 2:
            s2 = (minX,maxY,maxX,maxY)
        elif dir == 3:
            s2 = (minX,minY,minX,maxY)
        return self.intersect(s1,s2,False)
    if dir == -1:
        for d in [0,1,2,3]:
            points = self.clip_polygon(points,minX,minY,maxX,maxY,d)
            if not points:
                return None
        return points
    else:
        sp = points[-1]
        out_points = []
        for ep in points:
            if inside(ep,minX,minY,maxX,maxY,dir):
                if inside(sp,minX,minY,maxX,maxY,dir):
                    out_points.append(ep)
                else:
                    ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                    out_points.append(ip)
                    out_points.append(ep)
            else:
                if inside(sp,minX,minY,maxX,maxY,dir):
                    ip = intersect(sp,ep,minX,minY,maxX,maxY,dir)
                    out_points.append(ip)
            sp = ep
        return out_points if out_points else None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.cross_product_length">
    <p>def <span class="ident">cross_product_length</span>(</p><p>self, pA, pB, pC)</p>
    </div>
    

    
  
    <div class="desc"><p>compute the cross product of AB x BC</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.cross_product_length', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.cross_product_length" class="source">
    <pre><code>def cross_product_length( self, pA,pB,pC ):
    """ compute the cross product of AB x BC """
    BAx = float(pA[0] - pB[0])
    BAy = float(pA[1] - pB[1])
    BCx = float(pC[0] - pB[0])
    BCy = float(pC[1] - pB[1])
    return (BAx * BCy - BAy * BCx)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.from_rowcol">
    <p>def <span class="ident">from_rowcol</span>(</p><p>self, row, col)</p>
    </div>
    

    
  
    <div class="desc"><p>return the pixel location of a character position, returns upper left pixel in matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.from_rowcol', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.from_rowcol" class="source">
    <pre><code>def from_rowcol(self, row, col ):
    """ return the pixel location of a character position, returns upper left pixel in matrix"""
    return (int(row)*2,int(col)*2)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.get_bounds">
    <p>def <span class="ident">get_bounds</span>(</p><p>self, points)</p>
    </div>
    

    
  
    <div class="desc"><p>return tuple (min_x,min_y,max_x,max_y) for list of points</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.get_bounds', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.get_bounds" class="source">
    <pre><code>def get_bounds(self,points):
    """ return tuple (min_x,min_y,max_x,max_y) for list of points """
    min_x = -1
    min_y = -1
    max_x = -1
    max_y = -1
    for x,y in points:
        if min_x < 0 or x < min_x:
            min_x = x
        if min_y < 0 or y < min_y:
            min_y = y
        if max_x < 0 or x > max_x:
            max_x = x
        if max_y < 0 or y > max_y:
            max_y = y
    return (min_x,min_y,max_x,max_y)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.get_maxxy">
    <p>def <span class="ident">get_maxxy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>return the maximum number of x and y pixels that are available in this canvas</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.get_maxxy', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.get_maxxy" class="source">
    <pre><code>def get_maxxy( self ):
    """ return the maximum number of x and y pixels that are available in this canvas """
    return (self.max_x,self.max_y)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.init_win">
    <p>def <span class="ident">init_win</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>initializes the window and sets up all of the defaults</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.init_win', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.init_win" class="source">
    <pre><code>def init_win(self):
    """ initializes the window and sets up all of the defaults """
    curses.init_pair(5,curses.COLOR_BLACK,curses.COLOR_BLACK)
    curses.init_pair(1,curses.COLOR_GREEN,curses.COLOR_BLACK)
    curses.init_pair(2,curses.COLOR_RED,curses.COLOR_BLACK)
    curses.init_pair(3,curses.COLOR_CYAN,curses.COLOR_BLACK)
    curses.init_pair(4,curses.COLOR_WHITE,curses.COLOR_BLACK)
    self.green = curses.color_pair(1)
    self.red = curses.color_pair(2)
    self.cyan = curses.color_pair(3)
    self.white = curses.color_pair(4)
    self.black = curses.color_pair(5)
    if curses.can_change_color():
        self.color_min = 8
        self.color_max = 256
        red = 0
        green = 100
        blue = 20
        for c in range(self.color_min,self.color_max):
            curses.init_color(c,red,green,blue)
            red += 23
            green += 33
            blue += 53
            red = red % 1000
            green = green % 1000
            blue = blue % 1000
        for cidx in range(self.color_min,self.color_max):
            curses.init_pair(cidx,cidx,curses.COLOR_BLACK)
    else:
        self.color_min = 0
        self.color_max = 8
    if self.win:
        self.max_y,self.max_x = self.win.getmaxyx()
        self.char_map = [[None] * self.max_y for i in range(self.max_x)]
        self.max_y = self.max_y * 2
        self.max_x = self.max_x * 2
    else:
        self.max_y,self.max_x = (0,0)
        self.char_map = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.intersect">
    <p>def <span class="ident">intersect</span>(</p><p>self, seg1, seg2, clip_to_seg=False)</p>
    </div>
    

    
  
    <div class="desc"><p>find the intersection of two segments as tuples (x0,y0,x1,y1) returns tuple (x,y) if no intersection returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.intersect', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.intersect" class="source">
    <pre><code>def intersect( self, seg1, seg2, clip_to_seg = False ):
    """ find the intersection of two segments as tuples (x0,y0,x1,y1) returns tuple (x,y) if no intersection returns None """
    def lineform( seg ):
        """ return A, B, C for the standard line formula Ax + By = C """
        A = float(seg[1]-seg[3])
        B = float(seg[2]-seg[0])
        C = A*seg[0]+B*seg[1]
        return (A,B,C)
    l1 = lineform(seg1)
    l2 = lineform(seg2)
    det = l1[0]*l2[1] - l2[0]*l1[1]
    if det != 0:
        x = (l2[1]*l1[2] - l1[1]*l2[2])/det
        y = (l1[0]*l2[2] - l2[0]*l1[2])/det
        if clip_to_seg:
            if x >= min(seg1[0],seg1[2]) and x <= max(seg1[0],seg1[2]) and y >= min(seg1[1],seg1[3]) and y <= max(seg1[1],seg1[3]):
                return (int(x),int(y))
        else:
            return (int(x),int(y))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.is_convex">
    <p>def <span class="ident">is_convex</span>(</p><p>self, points)</p>
    </div>
    

    
  
    <div class="desc"><p>take a list of (x,y) tuples representing the vertecies of a polygon in order and return True if it represents a convex polygon, False otherwise</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.is_convex', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.is_convex" class="source">
    <pre><code>def is_convex( self, points ):
    """ take a list of (x,y) tuples representing the vertecies of a polygon in order and return True if it represents a convex polygon, False otherwise """
    got_negative = False
    got_positive = False
    num_points = len(points)
    if num_points <= 3:
        return True
    min_x,min_y,max_x,max_y = self.get_bounds(points)
    if max_x-min_x <= 1.0 or max_y-min_y <= 1.0:
        return True
    for A in range(num_points):
        B = (A+1)%num_points
        C = (B+1)%num_points
        cross_product = self.cross_product_length(points[A],points[B],points[C])
        if cross_product < 0:
            got_negative = True
        elif cross_product > 0:
            got_positive = True
    return not (got_negative and got_positive)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.line">
    <p>def <span class="ident">line</span>(</p><p>self, x0, y0, x1, y1, color, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a line between x0,y0 and x1,y1 in color</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.line', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.line" class="source">
    <pre><code>def line(self, x0, y0, x1, y1, color, put_pixel=None ):
    """ draw a line between x0,y0 and x1,y1 in color """
    x0 = int(x0)
    x1 = int(x1)
    y0 = int(y0)
    y1 = int(y1)
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 > x1 else 1
    sy = -1 if y0 > y1 else 1
    if dx > dy:
        err = dx / 2.0
        while x != x1:
            if put_pixel:
                put_pixel(x,y,color)
            else:
                self.put_pixel(x, y, color)
            err -= dy
            if err < 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            if put_pixel:
                put_pixel(x,y,color)
            else:
                self.put_pixel(x, y, color)
            err -= dx
            if err < 0:
                x += sx
                err += dy
            y += sy
    if put_pixel:
        put_pixel(x, y, color)
    else:
        self.put_pixel(x,y,color)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.poly_fill">
    <p>def <span class="ident">poly_fill</span>(</p><p>self, points, color, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>fill a concave polygon by recursively subdividing until we get a convex polygon</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.poly_fill', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.poly_fill" class="source">
    <pre><code>def poly_fill(self,points,color,put_pixel = None):
    """ fill a concave polygon by recursively subdividing until we get a convex polygon """
    clips = []
    minX,minY,maxX,maxY = self.get_bounds(points)
    minX = float(minX)
    minY = float(minY)
    maxX = float(maxX)
    maxY = float(maxY)
    midX = (minX+maxX)/2.0
    midY = (minY+maxY)/2.0
    clips.append((minX,minY,midX,midY))
    clips.append((midX,minY,maxX,midY))
    clips.append((midX,midY,maxX,maxY))
    clips.append((minX,midY,midX,maxY))
    while clips:
        minX,minY,maxX,maxY = clips.pop(0)
        if int(minX)==int(maxX) or int(minY)==int(maxY):
            continue
        p = self.clip_polygon(points,minX,minY,maxX,maxY)
        if p:
            if self.is_convex(p):
                self.polygon(p,color,True,put_pixel)
            else:
                midX = (minX+maxX)/2.0
                midY = (minY+maxY)/2.0
                if midX - minX < 1.0 or midY - minY < 1.0 or maxX - midX < 1.0 or maxY - midY < 1.0:
                    continue
                clips.append((minX,minY,midX,midY))
                clips.append((midX,minY,maxX,midY))
                clips.append((midX,midY,maxX,maxY))
                clips.append((minX,midY,midX,maxY))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.polygon">
    <p>def <span class="ident">polygon</span>(</p><p>self, points, color, fill=False, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a polygon defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color
the last point will be connected to the first point. polygons can be filled.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.polygon', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.polygon" class="source">
    <pre><code>def polygon(self,points,color,fill=False,put_pixel=None):
    """ draw a polygon defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color
    the last point will be connected to the first point. polygons can be filled. """
    if not points:
        return
    convex = True
    if fill:
        convex = self.is_convex(points)
    poly_pixels = []
    def put_poly_pixel(x,y,color):
        poly_pixels.append((x,y))
    i = iter(points)
    first = p1 = next(i,None)
    while p1:
        p2 = next(i,None)
        if p2:
            last = p2
            self.line(p1[0],p1[1],p2[0],p2[1],color,put_poly_pixel)
        else:
            last = p1
            put_poly_pixel(p1[0],p1[1],color)
        p1 = p2
    self.line(first[0],first[1],last[0],last[1],color,put_poly_pixel)
    if not fill:
        for x,y in poly_pixels:
            if put_pixel:
                put_pixel(x,y,color)
            else:
                self.put_pixel(x,y,color)
    else:
        if convex:
            self.rasterize( poly_pixels, color, put_pixel)
        else:
            for x,y in poly_pixels:
                if put_pixel:
                    put_pixel(x,y,color)
                else:
                    self.put_pixel(x,y,color)
            self.poly_fill(points,color,put_pixel)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.polyline">
    <p>def <span class="ident">polyline</span>(</p><p>self, points, color, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a polyline defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.polyline', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.polyline" class="source">
    <pre><code>def polyline(self,points,color,put_pixel=None):
    """ draw a polyline defined by the sequence points which represent a list of (x,y) tuples in the order they should be connected in color """
    i = iter(points)
    p1 = next(i,None)
    while p1:
        p2 = next(i,None)
        if p2:
            self.line(p1[0],p1[1],p2[0],p2[1],color,put_pixel)
        else:
            if put_pixel:
                put_pixel(p1[0],p1[1],color)
            else:
                self.put_pixel(p1[0],p1[1],color)
        p1 = p2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.put_pixel">
    <p>def <span class="ident">put_pixel</span>(</p><p>self, x, y, color, set=True)</p>
    </div>
    

    
  
    <div class="desc"><p>turn on a pixel with the color indicated</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.put_pixel', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.put_pixel" class="source">
    <pre><code>def put_pixel( self, x,y, color, set = True ):
    """ turn on a pixel with the color indicated """
    if x < 0 or x >= self.max_x or y < 0 or y >= self.max_y:
        return
    row,col = self.to_rowcol(x,y)
    mask = self.to_mask[(int(x)%2)+((int(y)%2)*2)]
    if not self.char_map[col][row]:
        current_mask = 0
    else:
        current_mask = self.char_to_mask[self.char_map[col][row]]
    if set:
        self.char_map[col][row] = self.mask_to_char[ mask | current_mask ]
    else:
        self.char_map[col][row] = self.mask_to_char[ mask ^ current_mask ]
    try:
        self.win.addstr(row,col,self.char_map[col][row].encode('utf_8'),color)
    except:
        pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.rasterize">
    <p>def <span class="ident">rasterize</span>(</p><p>self, points, color, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>sort points representing the boundary of a filled shape and rasterize by filling lines with color</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.rasterize', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.rasterize" class="source">
    <pre><code>def rasterize( self, points, color, put_pixel=None):
    """ sort points representing the boundary of a filled shape and rasterize by filling lines with color """
    ps = sorted(points,key=lambda x: (x[1],x[0]))
    sp = iter(ps)
    p2 = p1 = next(sp,None)
    si = 0
    last = None
    while p2:
        last = p2
        p2 = next(sp,None)
        if not p2:
            if put_pixel:
                put_pixel(p1[0],p1[1],color)
            else:
                self.put_pixel(p1[0],p1[1],color)
        else:
            if p2[1] == p1[1]:
                continue
            else:
                self.line(p1[0],p1[1],last[0],last[1],color,put_pixel)
                p1 = p2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.rect">
    <p>def <span class="ident">rect</span>(</p><p>self, x0, y0, x1, y1, color, fill=False, put_pixel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a rectangle bounding x0,y0, x1,y1, in color == color optionally filling</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.rect', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.rect" class="source">
    <pre><code>def rect(self,x0,y0,x1,y1,color,fill=False,put_pixel=None):
    """ draw a rectangle bounding x0,y0, x1,y1, in color == color optionally filling """
    x0 = int(x0)
    x1 = int(x1)
    y0 = int(y0)
    y1 = int(y1)
    if not fill:
        self.line(x0,y0,x0,y1,color)
        self.line(x0,y1,x1,y1,color)
        self.line(x1,y1,x1,y0,color)
        self.line(x1,y0,x0,y0,color)
    else:
        if y1 < y0:
            y=y0
            y0=y1
            y1 = y
        for y in range(y0,y1):
            self.line(x0,y,x1,y,color,put_pixel)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.refresh">
    <p>def <span class="ident">refresh</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>refresh the display after drawing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.refresh', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.refresh" class="source">
    <pre><code>def refresh( self ):
    """ refresh the display after drawing """
    self.win.refresh()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.round_text_position">
    <p>def <span class="ident">round_text_position</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
    <div class="desc"><p>adjust a text position so that it always ends up down and to the right if it is at a half pixel offset</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.round_text_position', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.round_text_position" class="source">
    <pre><code>def round_text_position(self, x, y):
    """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
    r,c = self.to_rowcol(x,y)
    y1,x1 = self.from_rowcol(r,c)
    h,w = self.from_rowcol(1,1)
    if y1 < y:
        y = y + h/2
    if x1 < x:
        x = x + w/2
    return x, y
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.round_text_x_position">
    <p>def <span class="ident">round_text_x_position</span>(</p><p>self, x)</p>
    </div>
    

    
  
    <div class="desc"><p>adjust a text position so that it always ends up down and to the right if it is at a half pixel offset</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.round_text_x_position', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.round_text_x_position" class="source">
    <pre><code>def round_text_x_position(self, x):
    """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
    r,c = self.to_rowcol(x,0)
    y1,x1 = self.from_rowcol(r,c)
    h,w = self.from_rowcol(1,1)
    if x1 < x:
        x = x + w/2
    return x
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.round_text_y_position">
    <p>def <span class="ident">round_text_y_position</span>(</p><p>self, y)</p>
    </div>
    

    
  
    <div class="desc"><p>adjust a text position so that it always ends up down and to the right if it is at a half pixel offset</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.round_text_y_position', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.round_text_y_position" class="source">
    <pre><code>def round_text_y_position(self, y):
    """ adjust a text position so that it always ends up down and to the right if it is at a half pixel offset """
    r,c = self.to_rowcol(0,y)
    y1,x1 = self.from_rowcol(r,c)
    h,w = self.from_rowcol(1,1)
    if y1 < y:
        y = y + h/2
    return y
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.set_win">
    <p>def <span class="ident">set_win</span>(</p><p>self, win)</p>
    </div>
    

    
  
    <div class="desc"><p>point this canvas at a window and initialize things, will blank out the window</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.set_win', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.set_win" class="source">
    <pre><code>def set_win(self, win ):
    """ point this canvas at a window and initialize things, will blank out the window """
    self.win = win
    self.init_win()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.textat">
    <p>def <span class="ident">textat</span>(</p><p>self, x, y, color, message)</p>
    </div>
    

    
  
    <div class="desc"><p>draw a text message at a coordinate in the color specified</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.textat', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.textat" class="source">
    <pre><code>def textat(self,x,y,color,message):
    """ draw a text message at a coordinate in the color specified """
    x,y = self.round_text_position(x,y)
    height, width = self.from_rowcol(1,len(message))
    if x < 0 or x >self.max_x or y < 0 or y >self.max_y:
        return
    if y + height > self.max_y:
        return
    if x + height > self.max_x:
        clip_height,clip_width = self.to_rowcol(1,(self.max_x-x))
        if clip_width > 0:
            message = message[:clip_width]
        else:
            return
    row,col = self.to_rowcol(x,y)
    self.win.addstr(row,col,message.encode('utf_8'),color)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="char_draw.canvas.Canvas.to_rowcol">
    <p>def <span class="ident">to_rowcol</span>(</p><p>self, x, y)</p>
    </div>
    

    
  
    <div class="desc"><p>return character row col for input x,y coordinates</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-char_draw.canvas.Canvas.to_rowcol', this);">Show source &equiv;</a></p>
  <div id="source-char_draw.canvas.Canvas.to_rowcol" class="source">
    <pre><code>def to_rowcol(self, x, y ):
    """ return character row col for input x,y coordinates """
    return (int(y/2),int(x/2))
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
